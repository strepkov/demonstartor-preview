import * as math from "../libs/math.js";
import {Car} from "./car/Car";
import {Orientation} from "./coord/Orientation";
import {Sinput} from "./Sinput"
import {Soutput} from "./Soutput"
import {Track} from "./track/Track";

export {Simulator}

class Simulator {

//private generator: MontiarcToJavaGenerator;

    // fps = 1/s -> fpsTime is 1/fps
    public fpsTime;
    private velocity;
    private time;
    private car: Car;
    private track: Track;
    private output: Soutput; //stores the output data(new positions, degree, velocity etc.)

    public constructor() {

        // Initial velocity is 0 m/s, Initial time is 0 s
        this.velocity = math.unit('0 m/s'); // v
        this.time = math.unit('0 sec'); // t
        this.fpsTime = math.unit('1 sec');
        
        this.car = new Car(0,0);
        this.track = new Track();
    }

    public getTime(){
        return this.time;
    }

    public getOutput(): Soutput {
        return this.output;
    }

    // private resolver: Resolver;

    //  static {
    //     Path rPath = null;
    //     URL srcLocation = Simulator.class.getProtectionDomain().getCodeSource().getLocation();
    //     try {
    //         rPath = Paths.get(srcLocation.toURI());
    //     } catch (URISyntaxException e) {
    //         Log.error("Could not initialize Trigger resolver at location " + srcLocation);
    //     }
    //     resolver = Resolver.get(rPath);
    // }

    // public constructor(Path baseDirectory, Path generationDirectory, Path compileDirectory, ExpandedComponentInstanceSymbol inst) {
    //     this();
    //      this.generator = new MontiarcToJavaGenerator(baseDirectory, generationDirectory, compileDirectory, inst);
    // }

    // Updates the time, velocity, degree of car and new positions x,y
    public calculate(input: Sinput) {
        
        // time = t+(1/20)s, for t=0s
        let time_local = math.add(this.time, this.fpsTime);
        this.time = time_local;

        // velocity = v+(input)acceleration*(1/20)s, for v=0 m/ss
        let velocity_local = math.add(this.velocity, math.multiply(input.acceleration, this.fpsTime));  // TODO input
        this.velocity = velocity_local;

        let degree: number;
        let nullVelocity = math.unit('0 m/s');
        

        // calculation of car rotation
        if(velocity_local.equals(nullVelocity)){
             degree = this.car.getDegree();
        }
        else{
            degree = this.car.getDegree() + input.steering; // adjust steeriing angle
        }

        let degree1 = math.unit(degree, 'deg');

        //Calculate positioin of the car

        // x=(input)x+v*t*cos((rad)degree) // degree * Math.PI / 180 - radian conversioin
        let x = math.add(input.x0, (this.velocity.times(this.fpsTime).times(Math.cos(degree * Math.PI / 180))));

        // y=(input)y+v*t*sin((rad)degree) //Amount<Length>
        let y = math.minus(input.y0, (this.velocity.times(this.fpsTime).times(Math.sin(degree * Math.PI / 180))));

        this.output = new Soutput(this.velocity, x, y, this.time, degree1, input.doorStatus,
                input.indicatorStatus, input.lightTimerStatus, input.triggerStatus);
    }

    // send the updated position and the degree to the visualization as JSON package
    // private void transmit()

    // private JSONObject createJSON(SOutput output)

    public run() {
        
        let simulator = new Simulator();

        let input: Sinput = new Sinput(
                
            math.unit(0, 'm/s'), // a
            math.unit(0, 'deg'),  // s
            math.unit(0, 'meter'), // x
            math.unit(0, 'meter'), // y
            math.unit(0, 'sec'), // t
            false, // doorStatus
            false, //indicatorStatus
            false, //lightStatus
            false //triggerStatus
        );

        let distances: number[] = this.car.getDistancesFromSensors(this.track);

        // BasicSimulator sim = new BasicSimulator(basePath, genPath, compilePath, inst);

        // outputs = sim.execute();
    

        simulator.calculate(input);

        let output: Soutput = simulator.output; //SOutput will be filled with updated values

        // Give the updated t and v to the Generator/BasicSimulator and next loop
        while(true) {

            let v: number = output.velocity; // METERS_PER_SECOND
            let ti: number = output.ti; // SECOND
            let xi: number = output.xi; // METER
            let yi: number = output.yi; // METER
            let degree: number = output.degree; // DEGREE_ANGLE

            this.car.setPosition([xi,yi]);
            this.car.setDegree(degree);

            // nameStreamSymbols = getNamedStreamSymbols(getDistancesFromSensors(), portSymbols, ti, v, xi, yi);

            // outputs = sim.execute();

            // create input generated by controller
            // TODO: fill input with tha data from controller

            input = new Sinput(
                math.unit('0 m/s^2'), //acceleration
                math.unit('0 deg'), // steering, DEGREE_ANGLE
                output.xi,
                output.yi,
                output.ti,
                false, //doorStatus
                false, //indicatorStatus
                false, //lightStatus
                false  //triggerStatus
            );

            simulator.calculate(input);

            output = simulator.output; //SOutput will be filled with updated values

            //     Thread.sleep(100);
        }
    }

    // public void generate() {
    //     try {
    //         generator.generate();
    //     } catch (Exception e) {
    //         e.printStackTrace();
    //     }
    // }

    // public void getOutputs(Amount<Velocity> v, Amount<javax.measure.quantity.Duration> t) throws Exception {
    //     double velocity = v.doubleValue(METERS_PER_SECOND);
    //     double time = t.doubleValue(SECOND);

    //     Map<String, Object> input = new HashMap<>();
    //     input.put("velocity", velocity);
    //     input.put("time", time);

    //     Map<String, Object> output = generator.calculateOutput(input);

    //     Double acceleration = (Double) output.get("acceleration");
    //     Double steering = (Double) output.get("steering");
    //     System.out.println("a: "+acceleration+", s: "+steering);
    // }

    // public void getOutputs(Amount<Angle> angle, Amount<Length> x, Amount<Length> y,
    //                        Amount<Length> d1, Amount<Length> d2, Amount<Length> d3, Amount<Length> d4,
    //                        Amount<Length> d5, Amount<Length> d6, Amount<Length> d7, Amount<Length> d8)
    //         throws Exception {
    //     double angleDouble = angle.doubleValue(DEGREE_ANGLE);
    //     double xDouble = x.doubleValue(METER);
    //     double yDouble = y.doubleValue(METER);

    //     double d1Double = d1.doubleValue(METER);
    //     double d2Double = d2.doubleValue(METER);
    //     double d3Double = d3.doubleValue(METER);
    //     double d4Double = d4.doubleValue(METER);
    //     double d5Double = d5.doubleValue(METER);
    //     double d6Double = d6.doubleValue(METER);
    //     double d7Double = d7.doubleValue(METER);
    //     double d8Double = d8.doubleValue(METER);

    //     Map<String, Object> input = new HashMap<>();
    //     input.put("", angleDouble);
    //     input.put("", xDouble);
    //     input.put("", yDouble);
    //     input.put("", d1Double);
    //     input.put("", d2Double);
    //     input.put("", d3Double);
    //     input.put("", d4Double);
    //     input.put("", d5Double);
    //     input.put("", d6Double);
    //     input.put("", d7Double);
    //     input.put("", d8Double);

    //     Map<String, Object> output = generator.calculateOutput(input);
    //     Double acceleration = (Double) output.get("acceleration");
    //     Double steering = (Double) output.get("steering");

    //     System.out.println("a: "+acceleration+", s: "+steering);
    // }
}
